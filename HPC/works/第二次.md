1、搭建环境，练习Linux命令和gcc 编译器编译C代码，请给出Linux和gcc版本。  

2、自己做实验完成课件中的CreateThread实验，并变化线程数量进行分析（分析 g_Count++值的变化;请列表记录多次实验结果）；然后使用互斥量、信号量、条件变量、读写锁等线程同步机制保证g_Count 值的正确操作。给出程序，并多次运行观测输出值。提交程序和测试文档及其说明文档。

3、使用pthread库实现多线程矩阵乘法(Linux或者windows均可)，变化矩阵大小并分析不同线程个数下的加速比和计算效率。

4、运行并测试 课件中的OpenMP helloworld程序，设置不同线程个数并记录运行结果。

5、名词解释：作业调度或者负载均衡；加速比和效率；

```c
#include <stdio.h>
#include <windows.h>
#include <process.h>
#include <time.h>

#define MAX_NUM 16  //改变矩阵的阶数 

int C1[MAX_NUM][MAX_NUM]; //单线程结果矩阵 
int C2[MAX_NUM][MAX_NUM]; //4线程结果矩阵 
int C3[MAX_NUM][MAX_NUM]; //16线程结果矩阵 
int num_lst1[MAX_NUM][MAX_NUM]; //原矩阵1 
int num_lst2[MAX_NUM][MAX_NUM]; //原矩阵2 

void multiply_two_rows(int a[][MAX_NUM],int b[][MAX_NUM],int c[][MAX_NUM],int i,int j,int num); //定义一行和一列相乘的函数 
DWORD ThreadProc_4(LPVOID IpParam); //定义4线程函数 
DWORD ThreadProc_16(LPVOID IpParam); //定义16线程函数 
bool is_equal(int a[][MAX_NUM],int b[][MAX_NUM]); //判断结果矩阵是否相等 

int main(){    
    clock_t start,finish; //设定时间变量，用于计时 
    double Total_time; 
    printf("----------%d阶矩阵计算----------\n",MAX_NUM);

	//初始化原数组，随便取的数字 
    for(int i = 0;i < MAX_NUM;i++){
    	for(int j = 0;j < MAX_NUM;j++){
	    	num_lst1[i][j] = i;
	    	num_lst2[i][j] = i;
	    }
    }
    
    //单线程 
    start = clock(); //记录开始时间 
    
    //C1[i][j] = num_lst1[i][:]*num_lst2[:][j] 
    for(int i = 0;i < MAX_NUM;i++){
    	for(int j = 0;j < MAX_NUM;j++){
	    	multiply_two_rows(num_lst1,num_lst2,C1,i,j,MAX_NUM);
	    }
    }
    
    finish = clock(); //记录结束时间 
	Total_time = (double)(finish - start);
	printf("单线程共花了 %f ms\n", Total_time);
	
	
	//4线程 
	start = clock();  
    const int m_4 = 4; //设置线程数量 
    HANDLE hThread_4[m_4]; //设置线程数组 
    int a0=0,a1=1,a2=2,a3=3; //设置开始变量，见函数 ThreadProc_4。这边不能用数组，否则计算出来的矩阵结果不同！！ 初步认为应该是传参时出现错误。 
    
    //线程数组赋值 
    /* CreateThread参数如下，详细见： https://www.cnblogs.com/XiHua/p/5028329.html
	HANDLE WINAPI CreateThread
	( 
	  __in_opt   LPSECURITY_ATTRIBUTES lpThreadAttributes, // 指向SECURITY_ATTRIBUTES 的指针，为新线程指定安全描述 ，一般为NULL 
	  __in       SIZE_T dwStackSize, // 初始化线程堆栈尺寸 ,一般设为0 
	  __in       LPTHREAD_START_ROUTINE lpStartAddress, //线程函数所指向的地址起始函数，自定义函数需要使用(LPTHREAD_START_ROUTINE)强制转换类型！ 
	__in_opt   LPVOID lpParameter, // 给线程函数传递的参数，以取址的方式   
	__in       DWORD dwCreationFlags, // 有关线程的标志，一般设为0 
	 __out_opt  LPDWORD lpThreadId //系统分配给线程的ID，我们不需要知道，故设为NULL 
	 );
 	*/ 
    hThread_4[0] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ThreadProc_4, &a0, 0, NULL);
    hThread_4[1] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ThreadProc_4, &a1, 0, NULL);
    hThread_4[2] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ThreadProc_4, &a2, 0, NULL);
    hThread_4[3] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ThreadProc_4, &a3, 0, NULL);
    //进程开始执行  WaitForMultipleObjects(线程数量，线程数组，TRUE,INFINITE) 
    WaitForMultipleObjects(m_4, hThread_4, TRUE, INFINITE);
    
    finish = clock();
	Total_time = (double)(finish - start);
	printf("4线程共花了 %f ms，", Total_time);
	
	//判断用单线程计算出来的结果矩阵C1是否与4线程计算出来的结果矩阵C2相等。 
	if (is_equal(C1,C2)){
		printf("计算结果相等！\n");
	}
	else{
		printf("计算结果不相等！\n");
	}

	//16线程 
    start = clock();
    const int m_16 = 16;
    HANDLE hThread_16[m_16];
    int b0=0,b1=1,b2=2,b3=3,b4=4,b5=5,b6=6,b7=7,b8=8,b9=9,b10=10,b11=11,b12=12,b13=13,b14=14,b15=15;
    
    hThread_16[0] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ThreadProc_16, &b0, 0, NULL);
    hThread_16[1] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ThreadProc_16, &b1, 0, NULL);
    hThread_16[2] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ThreadProc_16, &b2, 0, NULL);
    hThread_16[3] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ThreadProc_16, &b3, 0, NULL);
    hThread_16[4] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ThreadProc_16, &b4, 0, NULL);
    hThread_16[5] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ThreadProc_16, &b5, 0, NULL);
    hThread_16[6] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ThreadProc_16, &b6, 0, NULL);
    hThread_16[7] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ThreadProc_16, &b7, 0, NULL);
    hThread_16[8] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ThreadProc_16, &b8, 0, NULL);
    hThread_16[9] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ThreadProc_16, &b9, 0, NULL);
    hThread_16[10] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ThreadProc_16, &b10, 0, NULL);
    hThread_16[11] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ThreadProc_16, &b11, 0, NULL);
    hThread_16[12] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ThreadProc_16, &b12, 0, NULL);
    hThread_16[13] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ThreadProc_16, &b13, 0, NULL);
    hThread_16[14] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ThreadProc_16, &b14, 0, NULL);
    hThread_16[15] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ThreadProc_16, &b15, 0, NULL);
    WaitForMultipleObjects(m_16, hThread_16, TRUE, INFINITE);
    
    finish = clock();
	Total_time = (double)(finish - start);
	printf("16线程共花了 %f ms，", Total_time);
	
	//判断用单线程计算出来的结果矩阵C1是否与16线程计算出来的结果矩阵C3相等。 
	if (is_equal(C1,C3)){
		printf("计算结果相等！\n");
	}
	else{
		printf("计算结果不相等！");
	}

    return 0;
}


// 计算一行乘于一列的函数 
void multiply_two_rows(int a[][MAX_NUM],int b[][MAX_NUM],int c[][MAX_NUM],int i,int j,int num){	
	int result=0;
	for(int n = 0;n < num;n++){
		result += a[i][n]*b[n][j];
	}
	c[i][j] = result;
}


// 定义4线程函数，传入的参数为i的初始数值。函数头照着网上抄的，我也不知道什么意思。。。。 
/*
	如果行i%4 == 0，执行第一个进程，即计算数值为4n的行号与另一矩阵的所有列的乘积。
	如果行i%4 == 1，执行第二个进程，即计算数值为(4n+1)的行号与另一矩阵的所有列的乘积。
	如果行i%4 == 2，执行第三个进程，即计算数值为(4n+2)的行号与另一矩阵的所有列的乘积。
	如果行i%4 == 3，执行第二个进程，即计算数值为(4n+3)的行号与另一矩阵的所有列的乘积。 
*/ 
DWORD ThreadProc_4(LPVOID IpParam){
	int start = *(int *)IpParam;
	for(int i = start;i < MAX_NUM;i += 4){
		for(int j = 0;j < MAX_NUM;j += 1){
			multiply_two_rows(num_lst1,num_lst2,C2,i,j,MAX_NUM);
		}
	}
	return 0;
}

//定义16线程函数，基本思想与上述4线程函数一致。 
DWORD ThreadProc_16(LPVOID IpParam){
	int start = *(int *)IpParam;
	for(int i = start;i < MAX_NUM;i += 16){
		for(int j = 0;j < MAX_NUM;j += 1){
			multiply_two_rows(num_lst1,num_lst2,C3,i,j,MAX_NUM);
		}
	}
	return 0;
}

//定义判等函数，如果两个矩阵中有一个元素不相等，则返回false，否则返回true。 
bool is_equal(int a[][MAX_NUM],int b[][MAX_NUM]){
	bool flag = true;
	for(int i = 0;i < MAX_NUM;i++){
		for(int j = 0;j < MAX_NUM;j++){
			if (a[i][j] != b[i][j]){
				flag = false;
				goto end;
			}
		}
	}
	end:
	return flag;
}

```